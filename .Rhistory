p <- (d <- dim(V))[1L]
sqrt(1/diag(V))
Is <- sqrt(1/diag(V))
r<-V
r <- Is * V * rep(Is, each = p)
r
p
1L:p
cbind(1L:p, 1L:p)
r[cbind(1L:p, 1L:p)]
##MATRICES TORCH
y <- gpu.matrix(1:4,2,2, dimnames = list(c("a","b"),c("c","d")))
determinant(y)
determinant(y,logarithm = F)
det(y)
fft(y)
sort(y)
sort(y,decreasing = T)
round(y)
round(y,digits = 1)
length(y)
dim(y) <- dim(y)
rownames(y) <- generar_strings_aleatorios(nrow(y),8)
colnames(y) <- generar_strings_aleatorios(ncol(y),8)
dimnames(y) <- list(generar_strings_aleatorios(nrow(y),8), generar_strings_aleatorios(ncol(y),8))
y[,c(1,2)]
y[,c(1,1,2)]
y[nrow(y),ncol(y)]
y[c(1,2),]
y[c(1,1,2),]
y[c(1,2)]
y[c(1,1,2)]
y[nrow(y)*ncol(y)]
rowSums(y)
colSums(y)
head(y)
head(y,1)
tail(y)
tail(y,1)
t(y)
if(y@sparse){
yS <- to_dense(y)
}else{
yS <- to_sparse(y)
}
a <- matrix(rnorm(nrow(y)*ncol(y)),nrow(y),ncol(y))
library(Matrix)
M <- as(a, "dgeMatrix")
crossprod(y,M)
crossprod(M,y)
tcrossprod(y,M)
tcrossprod(M,y)
solve(y,M)
solve(M,y)
cbind(y,M)
cbind(M,y)
rbind(y,M)
rbind(M,y)
chol_solve(y,M)
chol_solve(M,y)
cor(y,M)
cor(M,y)
cor(y,M,method = "spearman")
cor(M,y,method = "spearman")
cov(y,M)
cov(M,y)
y * M
M * y
y + M
M + y
y - M
M - y
y %*% M
M %*% y
y %x% M
M %x% y
y %% M
M %% y
y / M
M / y
M <- as(a, "dgCMatrix")
crossprod(y,M)
crossprod(M,y)
tcrossprod(y,M)
tcrossprod(M,y)
solve(y,M)
solve(M,y)
cbind(y,M)
cbind(M,y)
rbind(y,M)
rbind(M,y)
chol_solve(y,M)
chol_solve(M,y)
cor(y,M)
cor(M,y)
cor(y,M,method = "spearman")
cor(M,y,method = "spearman")
cov(y,M)
cov(M,y)
y * M
M * y
y + M
M + y
y - M
M - y
y %*% M
M %*% y
y %x% M
M %x% y
y %% M
M %% y
y / M
M / y
X <- matrix(rnorm(nrow(y)*ncol(y), mean=0, sd=1), nrow(y), ncol(y))
X <- X+1
X <- nearPD(X, corr=TRUE)$mat
M <- as(X, "dpoMatrix")
crossprod(y,M)
crossprod(M,y)
tcrossprod(y,M)
tcrossprod(M,y)
solve(y,M)
solve(M,y)
cbind(y,M)
cbind(M,y)
rbind(y,M)
rbind(M,y)
chol_solve(y,M)
chol_solve(M,y)
cor(y,M)
cor(M,y)
cor(y,M,method = "spearman")
cor(M,y,method = "spearman")
cov(y,M)
cov(M,y)
y * M
M * y
y + M
M + y
y - M
M - y
y %*% M
M %*% y
y %x% M
M %x% y
y %% M
M %% y
y / M
M / y
library(float)
floatA <- fl(a)
crossprod(y,floatA)
crossprod(floatA,y)
tcrossprod(y,floatA)
tcrossprod(floatA,y)
solve(y,floatA)
solve(gpu.matrix(floatA, device = GPUmatrix:::device(y)),y)
cbind(y,gpu.matrix(floatA, device = GPUmatrix:::device(y)))
cbind(gpu.matrix(floatA, device = GPUmatrix:::device(y)),y)
rbind(y,gpu.matrix(floatA, device = GPUmatrix:::device(y)))
rbind(gpu.matrix(floatA, device = GPUmatrix:::device(y) ),y)
chol_solve(y,gpu.matrix(floatA, device = GPUmatrix:::device(y)))
chol_solve(gpu.matrix(floatA, device = GPUmatrix:::device(y)),y)
cor(y,floatA)
cor(floatA,y)
cor(y,floatA,method = "spearman")
cor(floatA,y,method = "spearman")
cov(y,floatA)
cov(floatA,y)
y * floatA
floatA * y
y + floatA
floatA + y
y - floatA
floatA - y
y %*% floatA
floatA %*% y
y %x% floatA
floatA %x% y
y %% floatA
floatA %% y
y / floatA
floatA / y
#Sparse
crossprod(y,yS)
tcrossprod(y,yS)
solve(y,yS)
cbind(y,yS)
rbind(y,yS)
crossprod(yS,y)
tcrossprod(yS,y)
solve(yS,y)
cbind(yS,y)
rbind(yS,y)
chol_solve(y,yS)
chol_solve(yS,y)
cor(y,yS)
cor(yS,y)
cor(y,yS,method = "spearman")
cor(yS,y,method = "spearman")
cov(y,yS)
cor(yS,y,method = "spearman")
cov(y,yS)
cov(yS,y)
y * yS
yS * y
y + yS
yS + y
y - yS
yS - y
y %*% yS
yS %*% y
y %x% yS
yS %x% y
y %% yS
yS %% y
y / yS
yS / y
#SINGLE
crossprod(y)
tcrossprod(y)
solve(y)
chol_solve(M,y)
cor(y)
cor(y,method = "spearman")
cov(y)
#A
crossprod(y,a)
crossprod(a,y)
tcrossprod(y,a)
tcrossprod(a,y)
solve(y,a)
solve(a,y)
cbind(y,a)
cbind(a,y)
rbind(y,a)
rbind(a,y)
chol_solve(y,a)
chol_solve(a,y)
cor(y,a)
cor(a,y)
cor(y,a,method = "spearman")
cor(a,y,method = "spearman")
cov(y,a)
cov(a,y)
y * a
a * y
y + a
a + y
y - a
a - y
y %*% a
a %*% y
y %x% a
a %x% y
y %% a
a %% y
y / a
a / y
log(y)
log2(y)
log10(y)
log1p(y)
cos(y)
cosh(y)
acos(y)
acosh(y)
sin(y)
sinh(y)
asin(y)
asinh(y)
tan(y)
atan(y)
tanh(y)
atanh(y)
sqrt(y)
abs(y)
sign(y)
ceiling(y)
floor(y)
cumsum(y)
cumprod(y)
exp(y)
expm1(y)
diag(y) <- diag(y)
qr(y)
rankMatrix(y)
eigen(y)
r
r[cbind(1L:p, 1L:p)] <- 1
r[1,1]
r[1,1]<-2
r
r[c(1,2),c(1,2)]<-1
r
r
V <- warningInteger(V)
V <- warningSparseTensor_torch(V)
p <- (d <- dim(V))[1L]
Is <- sqrt(1/diag(V))
r<-V
r <- Is * V * rep(Is, each = p)
r
cbind(1L:p, 1L:p)
y
as.matrix(y)
library(GPUmatrix)
a <- gpu.matrix(1:9,nrow=3,ncol=3)
a
a %x% diag(1,3)
a <- gpu.matrix(rnorm(20*100),20,100)
density(a[1,])
plot(density(a[1,]))
hist(a[1,])
devtools::install(build_vignettes = TRUE)
unlink("vignettes/vignette_run_cache", recursive = TRUE)
devtools::check()
devtools::check(cran = T)
version
install.packages("tinytex")
tinytex:::install_tinytex()
install.packages("ulem")
tinytex::install_tinytex()
tinytex::reinstall_tinytex()
install.packages("pdflatex")
pdflatex
tinytex::pdflatex()
tinytex::pdflatex()
library(GPUmatrix)
install.packages("torch")
install.packages("tensorflow")
library(GPUmatrix)
library(torch)
detach("package:torch", unload = TRUE)
library(torch)
debug(library)
detach("package:torch", unload = TRUE)
library(torch)
undebug(library)
library(torch)
torch_tensor()
torch_tensor(c(1,2,3))
library(GPUmatrix)
if (installedTORCH) attachNamespace("torch")
installedTORCH <- requireNamespace("torch", quietly = T)
installedTORCH
tryCatch({torch_tensor(c(1,2,3))}, error = installTorch <<- F)
tryCatch({torch_tensor(c(1,2,3));installTorch <<- F}, error = installTorch <<- F)
installTorch
tryCatch({torch_tensor(c(1,2,3));installTorch <<- T}, error = installTorch <<- F)
installTorch
library(GPUmatrix)
library(GPUmatrix)
installTorch
library(GPUmatrix)
installTorch
library(GPUmatrix)
installTorch
library(GPUmatrix)
library(GPUmatrix)
library(GPUmatrix)
installedTENSORFLOW
installedTORCH
library(GPUmatrix)
installedTORCH
detach("package:torch", unload = TRUE)
library(GPUmatrix)
library(GPUmatrix)
installedTORCH
tryCatch({if(installedTORCH)torch_tensor(c(1,2,3));installTorch <- T}, error = installTorch <- F)
if(installedTORCH)torch_tensor(c(1,2,3));installTorch <- T
tryCatch({if(installedTORCH)torch_tensor(c(1,2,3));installTorch <- T}, error = installTorch <- F)
installTorch
tryInstallTorch <- function(){
if(installedTORCH){
installTorch<-T
tryCatch(torch_tensor(c(1,2,3)), error=function(e){return(F)})
}
}
tryInstallTorch()
tryInstallTorch <- function(){
if(installedTORCH){
tryCatch(withRestarts(
# Intenta ejecutar la expresión
torch_tensor(c(1,2,3)),
# Invoca el reinicio si no hay errores
exito = function() TRUE
), error=function(e){return(F)})
}
}
installTorch <- tryInstallTorch()
installTorch
tryInstallTorch <- function(){
if(installedTORCH){
tryCatch(withRestarts(
# Intenta ejecutar la expresión
torch_tensor(c(1,2,3)),
# Invoca el reinicio si no hay errores
exito = function() TRUE
exito
tryCatch(withRestarts(
# Intenta ejecutar la expresión
torch_tensor(c(1,2,3)),
# Invoca el reinicio si no hay errores
exito = function() TRUE,
exito
), error=function(e){return(F)})
torch_is_installed()
torch_is_installed
library(GPUmatrix)
library(GPUmatrix)
installTorch
library(GPUmatrix)
library(GPUmatrix)
installedTORCH
installTorch
if(installedTORCH & installTorch) packageStartupMessage("Torch tensors allowed")
installTorch
library(GPUmatrix)
installTorch
library(L0glm)
sim = simulate_spike_train(n=10000, p=10000, k=200, sparse=TRUE) # blurred spike train with 10000 timepoints & 200 blurred peaks
library(Matrix)
Xs = sim$X # sparse covariate matrix Xs of class dgCMatrix (time-shifted copies of the point spread function)
y = sim$y
weights <- 1/(y+0.1) # observation weights (approx 1/Poisson noise variance)
yw = y*sqrt(weights) # weighted y
ywaug = c(yw, rep(0, ncol(Xs))) # augmented weighted y
lambdas <- rep(1, ncol(Xs)) # ridge penalties on individual coefficients
Xsw <- Xs*Diagonal(x=sqrt(weights)) # weighted X
Xswaug <- rbind(Xsw, Diagonal(x=sqrt(lambdas))) # row augmented covariate matrix
# Cholesky decomposition based solve of weighted least squares problem
chol.solve = function (X, y, tol=.Machine$double.eps^(2/3)) {
ch <- base::chol(crossprod(X)) # solve using Cholesky decomposition
backsolve(ch, forwardsolve(ch, crossprod(X, y), upper = TRUE, trans = TRUE))
}
system.time(s1 <- chol.solve(Xswaug, ywaug))
system.time({Xswaug_gpu <- gpu.matrix(Xswaug, dtype = "float32", sparse = T)
ywaug_gpu <- gpu.matrix(ywaug, dtype = "float32", sparse = F)
s2 <- chol_solve(crossprod(Xswaug_gpu, ywaug_gpu),chol(crossprod(Xswaug_gpu)))
print(s2)})
library(GPUmatrix)
Xswaug_gpu <- gpu.matrix(Xswaug, dtype = "float32", sparse = F)
ywaug_gpu <- gpu.matrix(ywaug, dtype = "float32", sparse = F)
system.time({Xswaug_gpu <- gpu.matrix(Xswaug, dtype = "float32", sparse = T)
ywaug_gpu <- gpu.matrix(ywaug, dtype = "float32", sparse = F)
s2 <- chol_solve(crossprod(Xswaug_gpu, ywaug_gpu),chol(crossprod(Xswaug_gpu)))
print(s2)})
version
library(GPUmatrix)
library(torch)
library(L0glm)
sim = simulate_spike_train(n=10000, p=10000, k=200, sparse=TRUE) # blurred spike train with 10000 timepoints & 200 blurred peaks
library(Matrix)
Xs = sim$X # sparse covariate matrix Xs of class dgCMatrix (time-shifted copies of the point spread function)
y = sim$y
weights <- 1/(y+0.1) # observation weights (approx 1/Poisson noise variance)
yw = y*sqrt(weights) # weighted y
ywaug = c(yw, rep(0, ncol(Xs))) # augmented weighted y
lambdas <- rep(1, ncol(Xs)) # ridge penalties on individual coefficients
Xsw <- Xs*Diagonal(x=sqrt(weights)) # weighted X
Xswaug <- rbind(Xsw, Diagonal(x=sqrt(lambdas))) # row augmented covariate matrix
# Cholesky decomposition based solve of weighted least squares problem
chol.solve = function (X, y, tol=.Machine$double.eps^(2/3)) {
ch <- base::chol(crossprod(X)) # solve using Cholesky decomposition
backsolve(ch, forwardsolve(ch, crossprod(X, y), upper = TRUE, trans = TRUE))
}
Xswaug_gpu <- gpu.matrix(Xswaug, dtype = "float32", sparse = F)
ywaug_gpu <- gpu.matrix(ywaug, dtype = "float32", sparse = F)
Xswaug_gpu <- gpu.matrix(Xswaug,type = "tensorflow", dtype = "float32", sparse = F)
tf <- use_condaenv("tf")
Xswaug_gpu <- gpu.matrix(Xswaug,type = "tensorflow", dtype = "float32", sparse = F)
detach("package:tensorflow", unload = TRUE)
library(tensorflow)
tf <- use_condaenv("tf")
devtools::install_github("tomwenseleers/L0glm/L0glm")
install.packages("osqp")
install.packages("qlcMatrix")
devtools::install_github("tomwenseleers/L0glm/L0glm")
install.packages("Matrix")
devtools::install_github("tomwenseleers/L0glm/L0glm")
install.packages("Matrix")
library(Matrix)
devtools::install_github("tomwenseleers/L0glm/L0glm")
install.packages("i386")
install.packages("Rcpp")
devtools::install_github("tomwenseleers/L0glm/L0glm")
install.packages("glmnet")
devtools::install_github("tomwenseleers/L0glm/L0glm")
install.packages("devtools")
install.packages("nnls")
devtools::install_github("tomwenseleers/L0glm/L0glm")
library(L0glm)
sim = simulate_spike_train(n=10000, p=10000, k=200, sparse=TRUE) # blurred spike train with 10000 timepoints & 200 blurred peaks
library(Matrix)
Xs = sim$X # sparse covariate matrix Xs of class dgCMatrix (time-shifted copies of the point spread function)
y = sim$y
weights <- 1/(y+0.1) # observation weights (approx 1/Poisson noise variance)
yw = y*sqrt(weights) # weighted y
ywaug = c(yw, rep(0, ncol(Xs))) # augmented weighted y
lambdas <- rep(1, ncol(Xs)) # ridge penalties on individual coefficients
Xsw <- Xs*Diagonal(x=sqrt(weights)) # weighted X
Xswaug <- rbind(Xsw, Diagonal(x=sqrt(lambdas))) # row augmented covariate matrix
# Cholesky decomposition based solve of weighted least squares problem
chol.solve = function (X, y, tol=.Machine$double.eps^(2/3)) {
ch <- base::chol(crossprod(X)) # solve using Cholesky decomposition
backsolve(ch, forwardsolve(ch, crossprod(X, y), upper = TRUE, trans = TRUE))
}
library(GPUmatrix)
Xswaug_gpu <- gpu.matrix(Xswaug,type = "tensorflow", dtype = "float32", sparse = F)
tf <- use_condaenv("tf")
Xswaug_gpu <- gpu.matrix(Xswaug,type = "tensorflow", dtype = "float32", sparse = F)
